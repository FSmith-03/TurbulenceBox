! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


SUBROUTINE C_MATRIX_ROTATE(THETAX, THETAY, THETAZ, R_DIM_1, R_DIM_2, R) BIND(C)
  USE ISO_C_BINDING, ONLY: C_BOOL
  IMPLICIT NONE
  REAL, INTENT(IN) :: THETAX
  REAL, INTENT(IN) :: THETAY
  REAL, INTENT(IN) :: THETAZ
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: R_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: R_DIM_2
  REAL, INTENT(OUT), DIMENSION(R_DIM_1,R_DIM_2) :: R

  INTERFACE
    SUBROUTINE MATRIX_ROTATE(THETAX, THETAY, THETAZ, R)
      IMPLICIT NONE
      REAL, INTENT(IN) :: THETAX
      REAL, INTENT(IN) :: THETAY
      REAL, INTENT(IN) :: THETAZ
      REAL, INTENT(OUT), DIMENSION(3,3) :: R
    END SUBROUTINE MATRIX_ROTATE
  END INTERFACE

  CALL MATRIX_ROTATE(THETAX, THETAY, THETAZ, R)
END SUBROUTINE C_MATRIX_ROTATE


SUBROUTINE C_MATRIX_MULTIPLY(A_DIM_1, A_DIM_2, A, B_DIM_1, B_DIM_2, B, OUT_DIM_1, OUT_DIM_2, OUT) BIND(C)
  USE ISO_FORTRAN_ENV , ONLY : REAL64
  USE ISO_C_BINDING, ONLY: C_BOOL
  IMPLICIT NONE
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: A_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: A_DIM_2
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(A_DIM_1,A_DIM_2) :: A
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: B_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: B_DIM_2
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(B_DIM_1,B_DIM_2) :: B
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: OUT_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: OUT_DIM_2
  REAL(KIND=REAL64), INTENT(OUT), DIMENSION(OUT_DIM_1,OUT_DIM_2) :: OUT

  INTERFACE
    SUBROUTINE MATRIX_MULTIPLY(A, B, OUT)
      ! This subroutine multiplies the matrices A and B.
      !
      ! INPUT:
      !   A(M,N)  --  A 2D matrix of 64 bit floats.
      !   B(N,P)  --  A 2D matrix of 64 bit floats,
      !
      ! OUTPUT:
      !   OUT(M,P)  --  The matrix that is the result of (AB).
      USE ISO_FORTRAN_ENV , ONLY : REAL64
      IMPLICIT NONE
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(:,:) :: A
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(:,:) :: B
      REAL(KIND=REAL64), INTENT(OUT), DIMENSION(SIZE(A,1),SIZE(B,2)) :: OUT
    END SUBROUTINE MATRIX_MULTIPLY
  END INTERFACE

  CALL MATRIX_MULTIPLY(A, B, OUT)
END SUBROUTINE C_MATRIX_MULTIPLY


SUBROUTINE C_EDDY_RANGE(POS_VECTORS_DIM_1, POS_VECTORS_DIM_2, POS_VECTORS, FIRST_INDEX, LAST_INDEX, FACTOR_DIM_1, FACTOR) BIND(C)
  IMPLICIT NONE
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POS_VECTORS_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POS_VECTORS_DIM_2
  REAL(KIND=8), INTENT(IN), DIMENSION(POS_VECTORS_DIM_1,POS_VECTORS_DIM_2) :: POS_VECTORS
  INTEGER, INTENT(OUT) :: FIRST_INDEX
  INTEGER, INTENT(OUT) :: LAST_INDEX
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: FACTOR_DIM_1
  REAL(KIND=8), INTENT(OUT), DIMENSION(FACTOR_DIM_1) :: FACTOR

  INTERFACE
    SUBROUTINE EDDY_RANGE(POS_VECTORS, FIRST_INDEX, LAST_INDEX, FACTOR)
      IMPLICIT NONE
      REAL(KIND=8), INTENT(IN), DIMENSION(:,:) :: POS_VECTORS
      INTEGER, INTENT(OUT) :: FIRST_INDEX
      INTEGER, INTENT(OUT) :: LAST_INDEX
      REAL(KIND=8), INTENT(OUT), DIMENSION(:) :: FACTOR
    END SUBROUTINE EDDY_RANGE
  END INTERFACE

  CALL EDDY_RANGE(POS_VECTORS, FIRST_INDEX, LAST_INDEX, FACTOR)
END SUBROUTINE C_EDDY_RANGE


SUBROUTINE C_VELOCITY_GENERATOR(XAXIS_TRIMMED_DIM_1, XAXIS_TRIMMED_DIM_2, XAXIS_TRIMMED, FACTOR_DIM_1, FACTOR, U_DIM_1, U, V_DIM_1,&
& V, W_DIM_1, W) BIND(C)
  IMPLICIT NONE
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: XAXIS_TRIMMED_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: XAXIS_TRIMMED_DIM_2
  REAL(KIND=8), INTENT(IN), DIMENSION(XAXIS_TRIMMED_DIM_1,XAXIS_TRIMMED_DIM_2) :: XAXIS_TRIMMED
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: FACTOR_DIM_1
  REAL(KIND=8), INTENT(IN), DIMENSION(FACTOR_DIM_1) :: FACTOR
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: U_DIM_1
  REAL(KIND=8), INTENT(OUT), DIMENSION(U_DIM_1) :: U
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: V_DIM_1
  REAL(KIND=8), INTENT(OUT), DIMENSION(V_DIM_1) :: V
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: W_DIM_1
  REAL(KIND=8), INTENT(OUT), DIMENSION(W_DIM_1) :: W

  INTERFACE
    SUBROUTINE VELOCITY_GENERATOR(XAXIS_TRIMMED, FACTOR, U, V, W)
      IMPLICIT NONE
      REAL(KIND=8), INTENT(IN), DIMENSION(:,:) :: XAXIS_TRIMMED
      REAL(KIND=8), INTENT(IN), DIMENSION(:) :: FACTOR
      REAL(KIND=8), INTENT(OUT), DIMENSION(:) :: U
      REAL(KIND=8), INTENT(OUT), DIMENSION(:) :: V
      REAL(KIND=8), INTENT(OUT), DIMENSION(:) :: W
    END SUBROUTINE VELOCITY_GENERATOR
  END INTERFACE

  CALL VELOCITY_GENERATOR(XAXIS_TRIMMED, FACTOR, U, V, W)
END SUBROUTINE C_VELOCITY_GENERATOR


SUBROUTINE C_SENSOR_LINE_GENERATOR(X_BOUNDARY, NXF, POS_VECTOR_DIM_1, POS_VECTOR_DIM_2, POS_VECTOR) BIND(C)
  USE ISO_C_BINDING, ONLY: C_BOOL
  IMPLICIT NONE
  REAL(KIND=8), INTENT(IN) :: X_BOUNDARY
  INTEGER, INTENT(IN) :: NXF
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POS_VECTOR_DIM_1
  INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POS_VECTOR_DIM_2
  REAL(KIND=8), DIMENSION(POS_VECTOR_DIM_1,POS_VECTOR_DIM_2) :: POS_VECTOR

  INTERFACE
    FUNCTION SENSOR_LINE_GENERATOR(X_BOUNDARY, NXF) RESULT(POS_VECTOR)
      IMPLICIT NONE
      REAL(KIND=8), INTENT(IN) :: X_BOUNDARY
      INTEGER, INTENT(IN) :: NXF
      REAL(KIND=8), DIMENSION(3,NXF) :: POS_VECTOR
    END FUNCTION SENSOR_LINE_GENERATOR
  END INTERFACE

  POS_VECTOR = SENSOR_LINE_GENERATOR(X_BOUNDARY, NXF)
END SUBROUTINE C_SENSOR_LINE_GENERATOR

